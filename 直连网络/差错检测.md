### 组帧

组帧是数据链路层的**网络适配器(网卡)**需要完成的工作

适配器包含一个信令组件, 在发送方可以将比特编码为信号, 在接收方可以把信号解码为比特

网络结点间交换的是数据块(在数据链路层称为帧), 而不是比特流

- 关心的是帧，而不是比特序列，网络适配器使得结点之间能够交换帧


### 问题: 适配器如何组帧?(如何识别帧的位置和起止位置)

#### 两种方式

#### 面向字节的组帧:

- 早期使用的组帧方法, 把每一帧看成是一个字符(字节, ASCII码为8位的字节)的集合

    - 起止标记法
        
        - 使用一系列特定的字符表示帧的开始与结束
            - SYN(同步字符): 标志一帧开始发送
            - SOH(头部开始符)
            - STX(正文开始符)
            - ETX(正文结束符)
            - CRC(循环冗余校验位)
        - 问题: 如果正文部分也有特殊字符(e.g. 正文出现了结束字符ETX), 可能会引起数据解释错误(**数据帧的透明传输**)
            - 解决办法: 引入转义字符DLE(Data Link Escape, 数据通信换码符), 由发送方负责将数据部分所有的ETX用DLE填充进行转义, 同时DLE本身也需要进行转义
            - 如果遇到一个连续的DLE+ETX序列, 则接收方知道这个ETX不是结束字段的ETX。
    - 字节计数法
        - 在首部用一个特殊字段count记录本帧的长度(同时也应用SYN字符标志一帧的开始)

        - 问题: 如果count字段传输中出现差错, 可能会影响后续数据的读取(比如把本不属于本帧的部分计入本帧)

#### 面向比特的组帧

- 后期针对面向字节组帧方法的缺点改进的方法, 不再关心以字节为单位的比特段, 而是具体到以比特为单位的二进制位

    - 用一个特殊选定的标志字段来标志一帧的开始和结束
        - e.g. 01111110
        - 在链路空闲时, 也发送01111110序列以保证发方和收方的时钟同步
    - 问题(同样是透明传输问题): 如果数据部分也出现了01111110这个比特序列, 则会引起帧的边界判断错误
        - 解决方案: 比特填充法: 发送方在发送数据帧之前, 先用硬件或软件扫描一遍整个数据部分, 只要发现了5个连续的1, 就立即填入一个0
        - 接收方在读取数据时, 首先找出一个01111110序列确定帧开头, 之后向后读取数据部分:
            
            - 如果出现了连续5个1, 判断下一位比特的值:

                1. 如果下一位是0, 则一定是填充的0, 丢弃这一个0, 继续读取数据
                2. 如果下一位是1, 则继续判断下一个位, 如果下一个位是0, 则代表帧已经结束, 否则帧出错了(数据段出现了连续7个1)
### 差错检测

- 数据在传输过程中可能会出现**比特差错**
    - 传输过程中由于电磁干扰等出现了比特位反转
    - 传输错误的比特数占传输的总比特数的比率称为误码率(BER, Bit Error Rate)

- 差错检测的基本思想:
    - 在数据帧中引入冗余信息位来确定是否存在差错
    - 最极端的例子: 将同一个帧传输两份一样的副本, 若接收方收到的两个帧不相同, 则传输出错(低效且作用不大)
    - 实际上: 只需要k个冗余比特进行差错检测(k << n)
    - 接收方收到错误数据时:
        
        1. 可以通知发送方重新发送(重传机制)
        2. 通过加入的冗余码进行数据的恢复(纠错码)
- 冗余码检错方法:
    - 奇偶校验法(parity bit method)
        - 单向/单个位奇偶校验法(Row parity/Single bit parity)
            - 使用单个奇偶校验位(parity bit)
            - 分为奇校验(odd parity)和偶校验(even parity)
                - 奇校验: 发送的数据帧中1的个数和1比特校验位中1的个数的和为奇数
                - 偶校验: 发送的数据帧中1的个数和1比特校验位中1的个数的和为偶数
            - 问题: 只能检测出现了奇数比特差错的情况, 不能检测出现了偶数比特差错的情况
        - 二维奇偶校验法(2-dimensional parity bit)
            - 使用二维的奇偶校验序列进行奇偶校验
            - 将d比特信息划分为i行j列的二维矩阵, 对每行每列进行计算, 得出一个i+j+1位的奇偶校验序列
            - 问题: 1比特错误可以检测并纠错, 2比特错误只能检测, 无法纠错(无法通过两个行列信息确定两个点的位置)
        - 判断奇偶校验法泛用性不强, 需要引入其它检测方法
    - 检验和(checksum)方法
        - TCP/IP协议应用的经典方法(注意, IP只是不提供可靠传输, 不代表这里IP不会应用差错检测算法!!!!)
        - 基本思想为:  
        - **发送方**将传输的数据分为多个等长的字(e.g. 16比特的字), 对它们求和, 对结果取反码, 这个反码就是检验和 (注意计算时, 如果最高位有进位, 要回卷到最低位)
        - **接收方**对接收到的数据和检验和一起做加法(同样最高位有进位要回卷), 如果结果为全1, 则代表数据传输准确, 否则认为出现了差错
        - 问题: 检错能力不强: 
            - 如果只出现了一对单比特错误, 且其中一位由0变1, 另一位由1变0, 则最后的和仍为全1, 差错未检出
        - 不过思想简单, 且易于软件实现, 故广泛应用于TCP/IP这种上层协议中, 下层由链路层提供更强的差错检测