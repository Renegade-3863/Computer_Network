## 可靠传输

> 差错检测技术只能做到**无差错接受**
- 凡是接受的帧(即没有丢弃), 我们能以非常接近于1的概率认为这些帧在传输过程中没有产生差错
> 错误帧被接收方丢弃
- 有些纠错码技术可以恢复轻微的误码, 但计算开销太大
> 可靠传输
- 必须能够以某种方式恢复被丢弃或丢失的帧
- 可以应用于链路层, 传输层(TCP)和应用层 (IP层不提供可靠传输机制)

> 可靠传输基本机制
- **确认**和**超时**的组合
> **确认**(ACKnowledgement, ACK)
- 协议发给它的对等实体的消息, 告知它已收到刚才的帧

  - 可以是一个控制帧, 即无任何数据的头部
  - 也可以将一个ACK捎带在一个恰好要发向对方的数据帧中
> **超时**(timeout)
- 发送方收到一个确认, 表明帧发送成功; 如果在合理的一段时间后未收到确认, 那么它重发(retransmit)原始帧
- 等待一段合理时间的动作称为**超时**(timeout)

#### 自动请求重发(ARQ, Automatic Repeat Request)
- 使用确认与超时实现可靠传输的策略

#### 两种ARQ算法
- 停等算法(stop-and-wait)
    - 基本思想
        - 发送方传输了一帧后, 在传输下一帧之前等待一个ACK, 如果在某段时间之后ACK没有到达, 则发送方超时, 重发原始帧

        - 引入一个一位的帧编号, 原因: 重复帧问题(发送方过久未收到某一帧的确认帧, 而接收方已经收到了该帧并发送了确认帧, 此时发送方超时, 会重发原帧, 这时接收方会误认为重发的帧是下一帧, 重复接收了相同的帧)

        - 因为这一算法只允许链路上同时存在一个不同的帧(就是说不允许多个不同的帧同时在链路上传播, 故我们只需要一位的帧序号, 取值为0/1, 用来区分某一个帧是否是重发的帧)
    - 缺点:
        - 只允许链路上存在一个未确认的帧, 可能远远低于链路的容量
        e.g. RTT = 90ms的1.5Mbps的链路
            - 单向链路的时延带宽积为45ms * 1.5Mbps, 为67.7Kb, 约为8KB
            - 假设一帧为1KB, 则每个发送方一个RTT内只能发送一帧, 约占链路容量的1/8
            - 为完全利用链路, 希望发送方在等待一个ACK之前最多能够发送8帧
            - 疑问: 发送方等待第一个ACK的总时间应该是RTT, 为什么不是最多能够发送16帧?
            - 原因: 可以通过作图理解, 保持管道满载的基本思路是: 启动数据传输后只要达到了带宽最大利用率(即同一时刻, 管道中已经存在最大的帧数量), 之后就保持这一状态 。
            - 由于我们假设的是接收方在接收到一帧之后就立刻回发ACK确认**帧**(也是一个帧), 那么在发送方发送的第一个帧到达接收方后, 接收方就会回发一个ACK帧占据原来数据帧的传输带宽, 因而此时管道仍然是满载的, 故发送方此时不能继续发送帧。
            - 那么什么时候发送下一帧呢?
            - 应该在第一个ACK帧回到发送方的时候, 这个时候, 管道中就明确少了一个帧, 所以发送方可以继续发送下一个帧来维持管道满载。                
- 滑动窗口算法(sliding-window)
    - 依据停等算法的缺点, 作出的优化改进
    - 保持管道满载, 提升传输速率
        - 增加单位时间内传输数据帧的数目
    - 并发传输数据
        - 允许多个在途传输的数据帧(未收到ACK)
        - 通过窗口大小(window)来限制在途传输的数据帧个数
    
    - #### 发送方
        - 维护三个状态变量
            - 发送窗口大小(Send Window Size, SWS): 能够发送但未确认的帧数的上界(上界由前文所述的保持管道满载思想计算)
            - 最近被确认过的帧的序号(Last Acknowledgement Received, LAR)
            - 最近发送的帧的序号(Last Frame Sent, LFS)
    - #### 接收方
        - 维护三个状态变量
            - 接收窗口大小(Receive Window Size, RWS): 能够接收的无序帧数目上界
            - 最大的可接收帧的序号(Last Acceptable Frame, LAF)
            - 最后确认接收的帧的序号(Last Frame Received, LFR)
        - 操作:
            - 收到帧: LFR < SeqNum <= LAF, 帧在接收窗口内, 接收; 否则, 丢弃
            - 接收数据帧后, 将收到的最大连续数据帧的SeqNum作为ACK回复
    - #### 数据帧丢失:
        - 方案一: 回退N机制(Go-Back-N)恢复丢包
            - 接收方只对连续收到的数据帧回复ACK
            - 发送方接收不到新的ACK, 超时后重传LAR+1到LFS之间的数据帧
        - 方案二: 选择确认机制(Selective Acknowledgements)恢复丢包
            - 接收方准确的确认每个已接收的数据帧, 发送方根据这些信息更快重传
            - 传输效率更高, 但实现更复杂
    - #### 窗口大小
        - 发送方SWS
            - 可根据一段给定时间内链路上有多少待确认的帧来选择
            - 依据时延带宽积
        - 接收方RWS
            - RWS = 1: 接收方不缓存任何错序到达的帧
            - RWS = SWS: 接收方能够缓存发送方传输的任何帧
                - 原因: 反证法:
                    - 假设发送方某一时刻发送了一个序号为x的帧, 而此时接收方窗口为: [x-1-k, x-1], 那么发送方应该已经收到了接收方发来的关于x-1的确认信息, 而这又意味着所有小于等于x-1的序号的帧均已经被接收方接受了, 因此此时的接收方窗口一定会在x-1右侧, 且一定是[x, x+k], 与上面的假设矛盾。
                    - 只有当接收方窗口小于发送方窗口的时候, 才会出现发送方发送了一个序号为x+k+j(j > 0), 而接收方窗口为[x, x+k]的情况, 此时接收方会丢弃该帧
                    - 由此我们可以知道, 最优的情况就是RWS=SWS
            - 错序到达的帧不可能超过SWS个, RWS > SWS无意义

    - 序列号无限大的假设不成立
        - 序列号在大小有限的首部字段中
        - 序列号必须可重用, 能回绕
    - 需解决的问题:
        - 能够区别同一序列号的不同次发送
        - 可用序列号的数目必须大于所允许的待确认的帧的数目
    - RWS = SWS(前面提到的最优情况)时
        - (SWS+RWS) <= MaxSeqNum (MaxSeqNum = 2^n, n为序列号使用的比特数)
        - 即SWS = RWS <= 2^(n-1)
        - 发送窗口大小不能大于可用序列号数的一半
        - 证明方法很简单: 画个图看如果ACK丢失, 发送窗口重发的序号在序列号最大为多少时不会覆盖到接收方已经接收的帧(如果覆盖了会发生重复接收问题, 产生数据错误)
    
> 最后一个小总结

> 滑动窗口的整体参数确认流程:

> 首先根据链路的时延(单程传播时延)带宽积(容量), 确认发送窗口的上界, 之后尝试进行帧传输, 过程中由接收方反馈自己的可容纳帧数(接收窗口数量), 发送方根据接收方的反馈动态调节自己的发送窗口大小(使得RWS=SWS), 同时动态维护 RWS + SWS <= MaxSeqNum 这一关系。
